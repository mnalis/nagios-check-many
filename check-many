#!/usr/bin/perl -w
# GPLv3+ Matija Nalis <mnalis-perl@axe.tomsoft.hr> started 2016-10-28
# call multiple nagios plugins and check status

# FIXME use -T

our $VERSION='1.00';

use strict;

my @paths = qw(/usr/local/lib/nagios/plugins /usr/lib/nagios/plugins /usr/local/bin /usr/local/sbin /usr/bin /usr/sbin /bin /sbin);

my $DEBUG = 9;

my @exit_cmd = ();
my @exit_value = ();
my @exit_code = ();
my @exit_txt = ();
my @exit_perf = ();

my @NAGIOS_EXIT=('OK', 'WARNING', 'CRITICAL', 'UNKNOWN');


# parse command line options 
if (defined($ARGV[0]) and $ARGV[0] =~ /^(-h|--help)$/) {
    print <<EOF;
check-many v$VERSION

This plugin aggregates results of multiple other nagios
plugin checks, returning most critical status of them all 
and joining all performance data returned.

Options:
\t-h, --help
\t\tPrint this help screen

EOF
    exit 0;
}


# execute command if present
sub exec_cmd
{
    my $cmd = shift;

    foreach my $p (@paths) {	# find full path
      if (-e "$p/$cmd") { $cmd = "$p/$cmd"; last; }
    }
    
    $DEBUG > 1 && print "using full path for $cmd\n";
    
    my $args = join (' ', @_);
    return `$cmd $args`;
}

# executes command and handle output
sub handle_cmd
{
    my $cmd = $_[0];
    
    my $output = exec_cmd (@_);
    my $exit_sig = $? & 127;
    my $exit_code = $? >> 8;
    
    if ($exit_sig) {
       $exit_code = 3; $output = "UNKNOWN: kill_signal=$exit_sig; " . $output;
    }
    if ($exit_code > 3) {
       $exit_code = 3; $output = "UNKNOWN: exit_code=$exit_code; " . $output;
    }
    
    
    my $_code;
    my $_msg;
    my $_perf;
    
    $DEBUG > 2 && print "  for cmd=" . join(' ', @_) . ": \n";
    $DEBUG > 2 && print "\texit level:\t$NAGIOS_EXIT[$exit_code]\n";
#    print "\tfull=$output, code=$?\n";
    if ($output =~ /^(\S+\s+)?(OK|CRITICAL|WARNING|UNKNOWN)\s*[-:]?\s+(.*?)(\|(.*))?$/) {
         my $_prefix = $1 || '';
         $_code = $2;
         $_msg = $3;
         $_perf = defined($5) ? $5 : '';

         $_prefix =~ s{\s*$}{};
         $_msg = "$_prefix $_code: $_msg"
         # if $_msg ne 'OK' # include WARNING/ERROR string only if not-OK
         ;
         
         $DEBUG > 2 && print "\tfound output:\tprefix=$_prefix, code=$_code, msg=$_msg\n";
         $DEBUG > 2 && print "\tfound perf:\t$_perf\n" if $_perf;
    } else {
         $_code = $NAGIOS_EXIT[$exit_code];
         $_msg = "unknown output (${_code}?): $output"; chomp($_msg);
         $_perf = '';
         $DEBUG > 2 && print "\t$_msg\n";
         if ($exit_code == 0) { $exit_code = 3; $_code = 'UNKNOWN'; } # if error level indicated OK, but output is unparsable, set it to UNKNOWN
    }

    push @exit_cmd, join (' ', @_);
    push @exit_value, $exit_code;
    push @exit_code, $_code;
    push @exit_txt, $_msg;
    push @exit_perf, $_perf;
}

### MAIN ###

# read commands from STDIN - FIXME see other options from https://nagios-plugins.org/doc/check-many.html
my @commands=();
while (<STDIN>) {
  chomp;
  push @commands, $_;
}

# execute all commands in order
{
  foreach my $full (@commands) {
    my ($cmd, @args) = split ' ', $full;
    handle_cmd ($cmd, @args);
  }
}

if ($DEBUG > 1) {
  print "\n\n\n";
  print "commands = " . join ("\n", @exit_cmd) . "\n\n";
  print "values = " . join (", ", @exit_value) . "\n\n";
  print "code = " . join (", ", @exit_code) . "\n\n";
  print "txt = " . join ("\n", @exit_txt) . "\n\n";
  print "perf = " . join ("\n", @exit_perf) . "\n\n";
}


my $max_exit_level = 0;
my $output_code = '';
my $last_err = 'All checks OK.';
my $err_count = 0;
my $output_text = '';
my $perfdata = '';

my $last_cmd = $exit_cmd[0];
my $last_msg = '';
my $last_perf = '';

my @all = ();

# check if we have new maximum value 
# note that it is more complicated than simple integer check, as UNKNOWN state is not worst!
#
# rating is (from better to worse): (0=OK, 3=UNKNOWN, 1=WARNING, 2=CRITICAL)
# 
sub is_new_max
{
    my ($cur, $old) = @_;
    
    $DEBUG > 2 && print "check $old <=> $cur\n";
    die "invalid return value $old => $cur" if ($old > 3) or ($old < 0) or ($cur > 3) or ($cur < 0);
    
    if ($old == 0) { return 1 }			# if we were OK before, anything else is more important!
    if ($old == 2) { return 0 }			# if we were CRITICAL before, nothing else could be more important
    if ($old == 1) { return ($cur == 2) }	# if we were WARNING before, only CRITICAL is more important, others are not
    if ($old == 3) { return ($cur != 0) }	# if we were UNKNOWN before, only OK is less important
}

# consolidate output data
sub consolidate {
    my ($x) = @_;
    $DEBUG > 1 && print "consolidating at $x, last_cmd=$last_cmd\n";
    $DEBUG > 1 && print "full msg=$last_msg\n";
    $DEBUG > 1 && print "full perf=$last_perf\n\n";

    $last_msg =~ s/\n/, /g;
    push @all, { cmd=> $last_cmd, msg => $last_msg, perf => $last_perf };
    
    $last_msg = '';
    $last_perf = '';
    $last_cmd = $exit_cmd[$x];
}

# consolidate all checks (group by same cmd)
for my $x (0 .. $#exit_cmd) {
    consolidate($x) if ($exit_cmd[$x] ne $last_cmd);
    if (is_new_max($exit_value[$x], $max_exit_level)) {	# final result is worst result we've had (0=OK, 3=UNKNOWN, 1=WARNING, 2=CRITICAL);
        $max_exit_level = $exit_value[$x];
        $output_code = $exit_code[$x];
        if ($exit_value[$x]) {	# in non-OK status (needed because is_new_max(0,0) will return TRUE, etc)
            $err_count++;
            $last_err = "err(s). $err_count non-OK msgs, last is " . $exit_cmd[$x] .": " . $exit_txt[$x];
            $last_err =~ s/\n/; /g;
            $DEBUG > 1 && print "\t$err_count msgs, cur= " . $exit_txt[$x] . "\n";
        }
    }
    $last_msg .= ($last_msg?', ':'') . $exit_txt[$x];
    $last_perf .= ($last_perf?' ':'') . $exit_perf[$x];
    $DEBUG > 1 && print "x=$x, " . $exit_cmd[$x] . "\n";
}
consolidate($#exit_cmd);


# join output for multiple cmds if it is the same
my $prev_output = '';
my @prev_disks = ();
@all = sort {($a->{msg} cmp $b->{msg}) || $a->{disk} cmp $b->{disk} } @all;	# sort by output message (and disk)


# merge multiple messages for different disks
sub merge_msg
{
    return unless $prev_output;
    $output_text .= join(', ', @prev_disks) . ": $prev_output\n";
    $DEBUG > 1 && print "merge_msg prev=$prev_output for disks " . join(', ', @prev_disks) . "\n";
    @prev_disks = ();
}

for my $x (0 .. $#all) {
    if ($prev_output ne $all[$x]->{msg}) { merge_msg() }
    $perfdata .= $all[$x]->{disk} . ': ' .  $all[$x]->{perf} . "\n";
    $DEBUG > 2 && print "x=$x, disk=" . $all[$x]->{disk} . ", msg=" . $all[$x]->{msg} . "\n";
    $DEBUG > 3 && print "x=$x, disk=" . $all[$x]->{disk} . ", perf=" . $all[$x]->{perf} . "\n";
    $prev_output = $all[$x]->{msg};
    push @prev_disks, $all[$x]->{disk};
}
merge_msg();
chomp($output_text);


print "$output_code $last_err\n$output_text|$perfdata\n";
exit $max_exit_level;
