#!/usr/bin/perl -w GPLv3+ Matija Nalis <mnalis-perl@axe.tomsoft.hr> started
# 2016-10-28 call multiple nagios plugins and check status

# FIXME use -T

our $VERSION='1.01';

use strict;

my @paths = qw(/usr/local/lib/nagios/plugins /usr/lib/nagios/plugins /usr/local/bin /usr/local/sbin /usr/bin /usr/sbin /bin /sbin);

my $DEBUG = 0;

my @exit_cmd = ();
my @exit_value = ();
my @exit_code = ();
my @exit_txt = ();
my @exit_perf = ();

my @NAGIOS_EXIT=('OK', 'WARNING', 'CRITICAL', 'UNKNOWN');


# parse command line options 
if (defined($ARGV[0]) and $ARGV[0] =~ /^(-h|--help)$/) {
    print <<EOF;
check-many v$VERSION

This plugin aggregates results of multiple other nagios
plugin checks, returning most critical status of them all 
and joining all performance data returned.

Options:
\t-h, --help
\t\tPrint this help screen

EOF
    exit 0;
}


# execute command if present
sub exec_cmd
{
    my $cmd = shift;

    foreach my $p (@paths) {	# find full path
      if (-e "$p/$cmd") { $cmd = "$p/$cmd"; last; }
    }
    
    $DEBUG > 1 && print "using full path for $cmd\n";
    
    my $args = join (' ', @_);
    return `$cmd $args`;
}

# executes command and handle output
sub handle_cmd
{
    my $cmd = $_[0];
    
    my $output = exec_cmd (@_);
    my $exit_sig = $? & 127;
    my $exit_code = $? >> 8;
    
    if ($exit_sig) {
       $exit_code = 3; $output = "UNKNOWN: kill_signal=$exit_sig; " . $output;
    }
    if ($exit_code > 3) {
       $exit_code = 3; $output = "UNKNOWN: exit_code=$exit_code; " . $output;
    }
    
    
    my $_code;
    my $_msg;
    my $_perf;
    
    $DEBUG > 2 && print "  for cmd=" . join(' ', @_) . ": \n";
    $DEBUG > 2 && print "\texit level:\t$NAGIOS_EXIT[$exit_code]\n";
#    print "\tfull=$output, code=$?\n";
    if ($output =~ /^(\S+\s+)?(OK|CRITICAL|WARNING|UNKNOWN)\s*[-:]?\s+(.*?)(\|(.*))?$/) {
         my $_prefix = $1 || '';
         $_code = $2;
         $_msg = $3;
         $_perf = defined($5) ? $5 : '';

         $_msg = "${_prefix}${_code}: $_msg";
         $_prefix =~ s{\s*$}{};
         # if $_msg ne 'OK' # include WARNING/ERROR string only if not-OK
         ;
         
         $DEBUG > 2 && print "\tfound pre:\tprefix=$_prefix, code=$_code\n";
         $DEBUG > 2 && print "\tfound msg:\t$_msg\n";
         $DEBUG > 2 && print "\tfound perf:\t$_perf\n" if $_perf;
    } else {
         $_code = $NAGIOS_EXIT[$exit_code];
         $_msg = "${_code} (?): $output"; chomp($_msg);
         $_perf = '';
         $DEBUG > 2 && print "\tupdate msg:\t$_msg\n";
         if ($exit_code == 0) { $exit_code = 3; $_code = 'UNKNOWN'; } # if error level indicated OK, but output is unparsable, set it to UNKNOWN
    }

    push @exit_cmd, join (' ', @_);
    push @exit_value, $exit_code;
    push @exit_code, $_code;
    push @exit_txt, $_msg;
    push @exit_perf, $_perf;
}

# check if we have new maximum value 
# note that it is more complicated than simple integer check, as UNKNOWN state is not worst!
#
# rating is (from better to worse): (0=OK, 3=UNKNOWN, 1=WARNING, 2=CRITICAL)
# 
sub is_new_max
{
    my ($cur, $old) = @_;
    
    $DEBUG > 2 && print "check $old (old) <=> $cur (new)\n";
    die "invalid return value $old => $cur" if ($old > 3) or ($old < 0) or ($cur > 3) or ($cur < 0);
    
    if ($old == 0) { return 1 }			# if we were OK before, anything else is more important!
    if ($old == 2) { return 0 }			# if we were CRITICAL before, nothing else could be more important
    if ($old == 1) { return ($cur == 2) }	# if we were WARNING before, only CRITICAL is more important, others are not
    if ($old == 3) { return ($cur != 0) }	# if we were UNKNOWN before, only OK is less important
}

### MAIN ###

# read commands from STDIN - FIXME see other options from https://nagios-plugins.org/doc/check-many.html
my @commands=();
while (<STDIN>) {
  chomp;
  push @commands, $_;
}

# execute all commands in order
{
  foreach my $full (@commands) {
    my ($cmd, @args) = split ' ', $full;
    handle_cmd ($cmd, @args);
  }
}

if ($DEBUG > 0) {
  print "\n\n\n";
  print "commands =\n" . join ("\n", @exit_cmd) . "\n\n----------------------\n";
  print "values =\n" . join ("\n", @exit_value) . "\n\n----------------------\n";
  print "code =\n" . join ("\n", @exit_code) . "\n\n----------------------\n";
  print "txt =\n" . join ("\n", @exit_txt) . "\n\n----------------------\n";
  print "perf =\n" . join ("\n", @exit_perf) . "\n\n----------------------\n";
}


my $max_exit_level = 0;
my $output_code = '';
my $last_err = 'All checks OK.';
my $err_count = 0;
my $perfdata = '';

# consolidate all checks (group by same cmd)
for my $x (0 .. $#exit_cmd) {
    if ($exit_value[$x] > 0) { $err_count++; }
    if (is_new_max($exit_value[$x], $max_exit_level)) {	# final result is worst result we've had (0=OK, 3=UNKNOWN, 1=WARNING, 2=CRITICAL);
        $max_exit_level = $exit_value[$x];
        $output_code = $exit_code[$x];
        if ($exit_value[$x]) {	# in non-OK status (needed because is_new_max(0,0) will return TRUE)
            $last_err = "last is '" . $exit_cmd[$x] ."': " . $exit_txt[$x];
            $last_err =~ s/\n/; /g;
            $DEBUG > 1 && print "\t$err_count error msgs, cur= " . $exit_txt[$x] . "\n";
        }
    }
    $DEBUG > 1 && print "x=$x, " . $exit_cmd[$x] . " = $exit_txt[$x] --- $exit_perf[$x]\n";
    $perfdata .= "$exit_txt[$x]";	# always keep output msgs and perfdata in same order
    $perfdata .= " --- $exit_perf[$x]" if $exit_perf[$x];
    $perfdata .= "\n";
}
if ($max_exit_level) { $last_err = "err(s). $err_count non-OK msgs, " . $last_err; }

$DEBUG > 0 && print "\n---- FINAL RESULT ----\n";
print "$output_code $last_err|$perfdata\n";
exit $max_exit_level;
